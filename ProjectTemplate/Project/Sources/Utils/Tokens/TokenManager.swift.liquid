//
//  TokenManager.swift
//  {{ module_info.name }}
//
//  Created by {{ developer.name }} on {{ date }}.
//  Copyright {{ year }} {{ developer.company }}. All rights reserved.

import Moya

enum TokenRefreshResult {

    case newAnonymous
    case notNeedRefresh
    case refreshed
    case resetToAnonymous
}

protocol TokenManager: AnyObject {

    @discardableResult
    func refreshTokensIfNeeds() async -> Result<TokenRefreshResult, NetworkError>

    @discardableResult
    func refreshTokensIfNeeds(force: Bool) async -> Result<TokenRefreshResult, NetworkError>
    
    @discardableResult
    func fetchAnonymousToken() async -> Result<TokenRefreshResult, NetworkError>
}

class TokenManagerImpl {

    private let authProvider = MoyaProvider<AuthProvider>(
        session: .default,
        plugins: .plugins
    )

    private func fetchAnonymousToken(prevAuthentication: Authentication? = nil) async -> Result<TokenRefreshResult, NetworkError> {
        let result = await self.authProvider.makeRequest(.signInAnonymously)

        switch result {
        case .success(let response):
            if let authentication = Authentication(withJson: response["authentication"]) {
                Defaults.authentication = authentication
                let hasOldAuthentication = prevAuthentication?.isPersonal ?? false
                return .success(hasOldAuthentication ? .resetToAnonymous : .newAnonymous)
            } else {
                return .failure(.unrecognizedError)
            }

        case .failure(let error):
            return .failure(error)
        }
    }
}

extension TokenManagerImpl: TokenManager {
    
    func fetchAnonymousToken() async -> Result<TokenRefreshResult, NetworkError> {
        await self.fetchAnonymousToken(prevAuthentication: Defaults.authentication)
    }
    
    @discardableResult
    func refreshTokensIfNeeds() async -> Result<TokenRefreshResult, NetworkError> {
        await self.refreshTokensIfNeeds(force: false)
    }

    @discardableResult
    func refreshTokensIfNeeds(force: Bool) async -> Result<TokenRefreshResult, NetworkError> {
        guard let authentication = Defaults.authentication else {
            return await fetchAnonymousToken()
        }

        if authentication.accessToken.isValid && !force {
            return .success(.notNeedRefresh)
        }

        let result = await self.authProvider.makeRequest(.refreshToken(authentication: authentication))

        switch result {
        case .success(let response):
            if let authentication = Authentication(withJson: response["authentication"]) {
                Defaults.authentication = authentication
                return .success(.refreshed)
            } else {
                return .failure(.unrecognizedError)
            }

        case .failure(let error):
            if error.code == .invalidRefreshToken {
                return await fetchAnonymousToken(prevAuthentication: authentication)
            }
            return .failure(error)
        }
    }
}
